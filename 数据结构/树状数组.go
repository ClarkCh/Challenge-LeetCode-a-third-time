// +ignore
package 数据结构

func main() {

}

// 树状数组远没有别人表述的难以理解, 但是比较重要的一点是树状数组的适用范围
1.统计序列中在元素的左边比该元素小的元素的个数
2.求序列中第K大的元素
3.区间查询及单点修改(这个应用和线段树相似)
....

好像除了求第K大的元素外, 树状数组能做的线段树都能做, 核心原因应该是树状数组本身就是记录了更少的可推导信息的线段树,
也因此查询速度可能会比线段树慢一点, 因为记录的可推导信息少一些,
维护速度可能会比线段树快一点, 因为需要维护的可推导信息少一些

基础原理:有倾向性的求和数组的一部分(不求和所有情况的原因是节省资源), 目的是优化类似线段树求区间时的查询速度, 代价和线段树类似, 增加了维护的复杂度
但是维护的复杂度增加了很少, 从1到logN, 结果却是能使查询的复杂度从N到logN
相对来说, 树状数组就是牺牲部分大多数情况下用不到的可推导信息来优化的线段树

树状数组基于线段树的变更:
	利用二进制的进制优势来决定牺牲哪部分的可推导信息
	我们把类似线段树中用来储存可推导信息的数组称为magic
	把原数组称为data

如何构建magic数组:核心是明确magic[index]的构成方案,
	目前常见的构成方案是: 如果index本身是(2的幂)的倍数, 那么magic[index]将持有更多的data[index]信息

比如index=3->b11由于最低的1是在2的0次方的位置, 这说明这个index只能持有1个数据, 那就持有他本身的数据, 不收集更多数据
比如index=4->b100由于最低的1是在2的2次方的位置, 这说明这个index可以持有更多的数据, 他有权持有2的2次方数量个index的信息和

